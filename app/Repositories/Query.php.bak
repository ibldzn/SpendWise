<?php

namespace App\Repositories;

class Query
{
    private string $tableName;
    private string $primaryKey;
    private array $selectFields = [];
    private array $whereConditions = [];
    private array $groupByFields = [];
    private array $orderByFields = [];
    private array $joinClauses = [];
    private array $insertData = [];
    private array $updateData = [];
    private ?int $limit = null;
    private ?int $offset = null;
    private array $params = [];
    private string $queryType = 'SELECT';

    public function __construct(string $tableName, string $primaryKey)
    {
        $this->tableName = $tableName;
        $this->primaryKey = $primaryKey;
    }

    /**
     * Set the query type to SELECT and specify fields to retrieve.
     */
    public function select(array $fields): self
    {
        $this->queryType = 'SELECT';
        $this->selectFields = $fields;
        return $this;
    }

    /**
     * Add WHERE conditions.
     */
    public function where(array $conditions): self
    {
        foreach ($conditions as $key => $value) {
            $placeholder = ":where_$key";
            $this->whereConditions[] = "$key = $placeholder";
            $this->params[$placeholder] = $value;
        }
        return $this;
    }

    /**
     * Add JOIN clauses.
     */
    public function join(string $table, string $onCondition, string $type = 'INNER'): self
    {
        $this->joinClauses[] = "$type JOIN $table ON $onCondition";
        return $this;
    }

    /**
     * Add GROUP BY fields.
     */
    public function groupBy(array $fields): self
    {
        $this->groupByFields = $fields;
        return $this;
    }

    /**
     * Add ORDER BY fields.
     */
    public function orderBy(array $fields): self
    {
        $this->orderByFields = $fields;
        return $this;
    }

    /**
     * Set a LIMIT.
     */
    public function limit(int $limit): self
    {
        $this->limit = $limit;
        return $this;
    }

    /**
     * Set an OFFSET.
     */
    public function offset(int $offset): self
    {
        $this->offset = $offset;
        return $this;
    }

    /**
     * Set the query type to INSERT and specify data.
     */
    public function insert(array $data): self
    {
        $this->queryType = 'INSERT';
        $this->insertData = $data;
        return $this;
    }

    /**
     * Set the query type to UPDATE and specify data.
     */
    public function update(array $data): self
    {
        $this->queryType = 'UPDATE';
        $this->updateData = $data;
        return $this;
    }

    /**
     * Set the query type to DELETE.
     */
    public function delete(): self
    {
        $this->queryType = 'DELETE';
        return $this;
    }

    /**
     * Build and return the query string.
     */
    public function get(): string
    {
        $sql = match ($this->queryType) {
            'SELECT' => $this->buildSelectQuery(),
            'INSERT' => $this->buildInsertQuery(),
            'UPDATE' => $this->buildUpdateQuery(),
            'DELETE' => $this->buildDeleteQuery(),
            default => throw new \Exception('Invalid query type')
        };

        return $this->sanitizeSQL($sql);
    }

    /**
     * Build SELECT query.
     */
    private function buildSelectQuery(): string
    {
        $fields = $this->selectFields ? implode(', ', $this->selectFields) : '*';
        $joins = implode(' ', $this->joinClauses);
        $where = $this->whereConditions ? 'WHERE ' . implode(' AND ', $this->whereConditions) : '';
        $groupBy = $this->groupByFields ? 'GROUP BY ' . implode(', ', $this->groupByFields) : '';
        $orderBy = $this->orderByFields ? 'ORDER BY ' . implode(', ', $this->orderByFields) : '';
        $limit = $this->limit !== null ? "LIMIT {$this->limit}" : '';
        $offset = $this->offset !== null ? "OFFSET {$this->offset}" : '';

        return "SELECT $fields FROM {$this->tableName} $joins $where $groupBy $orderBy $limit $offset";
    }

    /**
     * Build INSERT query.
     */
    private function buildInsertQuery(): string
    {
        $fields = implode(', ', array_keys($this->insertData));
        $placeholders = implode(', ', array_map(fn ($key) => ":insert_$key", array_keys($this->insertData)));

        foreach ($this->insertData as $key => $value) {
            $this->params[":insert_$key"] = $value;
        }

        return "INSERT INTO {$this->tableName} ($fields) VALUES ($placeholders)";
    }

    /**
     * Build UPDATE query.
     */
    private function buildUpdateQuery(): string
    {
        $setClauses = [];
        foreach ($this->updateData as $key => $value) {
            $placeholder = ":update_$key";
            $setClauses[] = "$key = $placeholder";
            $this->params[$placeholder] = $value;
        }
        $set = implode(', ', $setClauses);
        $where = $this->whereConditions ? 'WHERE ' . implode(' AND ', $this->whereConditions) : '';

        return "UPDATE {$this->tableName} SET $set $where";
    }

    /**
     * Build DELETE query.
     */
    private function buildDeleteQuery(): string
    {
        $where = $this->whereConditions ? 'WHERE ' . implode(' AND ', $this->whereConditions) : '';
        return "DELETE FROM {$this->tableName} $where";
    }

    /**
     * Sanitize the query by replacing placeholders with their sanitized values.
     */
    private function sanitizeSQL(string $sql): string
    {
        foreach ($this->params as $placeholder => $value) {
            $sanitizedValue = is_numeric($value) ? $value : "'" . addslashes($value) . "'";
            $sql = str_replace($placeholder, $sanitizedValue, $sql);
        }
        return $sql;
    }
}
